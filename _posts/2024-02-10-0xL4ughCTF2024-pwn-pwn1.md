# 0xL4ughCTF2024 PWN - Pwn1

![image](https://github.com/fyrepaw13/fyrepaw13.github.io/assets/62428064/3077be0a-a14b-44d0-aba1-eb83bab960de)

The pwn1 challenge was a medium difficulty pwn challenge with 63 solves

## Initial Analysis

Unzipping the file gives us an ELF file, libc-2.31 and the loader for it. To start off, we will first patch the binary using [pwninit](https://github.com/io12/pwninit) to use the provided libc.

```shell
└─$ file chall_patched     
chall_patched: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./ld-2.31.so, BuildID[sha1]=96e20e69c031cc67b1471e7f8435b9967b5a155f, for GNU/Linux 3.2.0, not stripped
```

Its a 64-bit executable and it is not stripped so thats always helpful.

```shell
└─$ checksec --file=chall_patched 
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Full RELRO      Canary found      NX enabled    PIE enabled     No RPATH   RW-RUNPATH   77 Symbols        No    0               1               chall_patched
```

Looks like all the protections are enabled.

![image](https://github.com/fyrepaw13/fyrepaw13.github.io/assets/62428064/1d16fe99-296d-4339-b3ee-40248d2396bc)

Running the binary shows that it is one of those menu challenges where you can manage your notes.

## Decompiled Code

```c
undefined8 main(EVP_PKEY_CTX *param_1)

{
  long in_FS_OFFSET;
  int option;
  int noteToDelete;
  int totalNotes;
  char *local_1b8;
  char *pChunk;
  char *notes [51];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  init(param_1);
  totalNotes = 0;
  while( true ) {
    while( true ) {
      while( true ) {
        while( true ) {
          while( true ) {
            menu();
            __isoc99_scanf("%d",&option);
            getchar();
            if (option != 1) break;
            pChunk = (char *)malloc(0x28);
            puts("Enter the note");
            fgets(pChunk,10,stdin);
            puts("Note created");
            notes[totalNotes] = pChunk;
            totalNotes = totalNotes + 1;
          }
          if (option != 2) break;
          puts("Which note do you want to delete?");
          __isoc99_scanf("%d",&noteToDelete);
          getchar();
          if (totalNotes < noteToDelete) {
            puts("Invalid choice");
          }
          else {
            free(notes[noteToDelete + -1]);
          }
        }
        if (option != 3) break;
        puts("Which note do you want to edit?");
        __isoc99_scanf("%d",&noteToDelete);
        getchar();
        if (totalNotes < noteToDelete) {
          puts("Invalid choice");
        }
        else {
          fgets(notes[noteToDelete + -1],100,stdin);
          puts("Note edited");
        }
      }
      if (option != 4) break;
      puts("Which note do you want to read?");
      __isoc99_scanf("%d",&noteToDelete);
      getchar();
      if (totalNotes < noteToDelete) {
        puts("Invalid choice");
      }
      else {
        puts(notes[noteToDelete + -1]);
      }
    }
    if (option == 5) break;
    if (option == 10) {
      local_1b8 = (char *)malloc(0x4b0);
      puts("Enter the note");
      fgets(local_1b8,10,stdin);
      puts("Note created");
      notes[totalNotes] = local_1b8;
      totalNotes = totalNotes + 1;
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```

From the decompiled code above, we can see that option 1 creates a note by allocating memory from the heap and adds the pointer to that chunk into an array. 
Option 2 lets us delete a note by free-ing up the heap chunk. However, the pointer to that specific chunk is still inside our array which gives us a Use-After-Free vulnerability. 
Option 3 lets us edit a note but theres an obvious buffer overflow there. 
Option 4 lets us read the content inside the heap chunk which we will use to get leaks later. 
Additionally, theres option 10 which creates a really big heap chunk.
